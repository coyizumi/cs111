    /****************************************************************/
   /                   #######################                      /
  /                    ## Asgn 3 Design Doc ##                     /
 /                     #######################                    /
/****************************************************************/



#---------------------------------------------------------------------------#
# PART 1: Implementing a custom paging algorithm                            #
# The following functions were modified to implement Slim Chance Algorithm  #
#---------------------------------------------------------------------------#

((1))
----------------------------------------------------------------------
# vm_pageout.c: vm_pageout_scan(struct vm_domain *vmd, int pass)

This function does most of the work for the pageout system. It scans
pages to determine if any need to be moved to a different queue.

We have added several counters that keep track of:
	1. The number of inactive pages scanned
	2. The number of active pages scanned
	3. The number of pages moved from active to inactive
	4. The number of pages moved from inactive to active
	5. The number of pages moved to cache
	6. The number of pages freed
	7. The number of pages flushed

At the end of the function, we print these 7 counters as well as the
number of pages within the active and inactive queues.

((2))
----------------------------------------------------------------------
# vm_page.c: vm_page_enqueue(int queue, vm_page_t m)

This function adds the given page to the specified queue (either 
active or inactive). We have changed it so that it adds pages to the
head of the queue, rather than the tail.

((3))
----------------------------------------------------------------------
# vm_page.c: vm_page_requeue(vm_page_t m)

This function removes and then requeues the given page. We have
changed it so that it adds pages to the head of the queue, rather than
the tail.

((4))
----------------------------------------------------------------------
# vm_page.c: vm_page_requeue_locked(vm_page_t m)

Same as vm_page_requeue, but the pagequeue must be locked beforehand.
We have modified this function in the same way we modified
vm_page_requeue.

((5))
----------------------------------------------------------------------
# vm_phys.c: vm_freelist_add(struct vm_freelist *fl,
                            vm_page_t m, int order, int tail)

This function adds the page to the freelist. It takes in a variable
specifying whether the page should be added to the head or the tail.
We have changed it to insert the page at the side of the queue that is
opposite the side specified.



#------------------------------------------------------------------------#
# PART 2: Testing Methodology                                            #
# A series of tests were run to determine the differences between the    #
# Slim Chance algorithm and the generic algorithm.                       #
#------------------------------------------------------------------------#

# Creating Memory Stress

To force memory scarcity, we reduced the machine's memory to 256MB. This
is very close to FreeBSD's minimum requirement of 64MB. Since the system 
memory is so low it will force the OS to start paging out memory to disk. 

To stress this memory, we ran the following command:
	$ stress-ng -m 1 --vm-bytes 1G


# Gathering the Data

We formatted our logging statements in such a way that they could
easily be extracted using awk. The following command was used to
convert our system logs into a csv file (separated onto 3 lines):

	$ tail -F /var/log/messages | gawk '$6 ~ /^PAGEOUTd/ {print $3 \
		"," $7 "," $8 "," $9 "," $10 "," $11 "," $12 "," $13 \
		"," $14 "," $15 > "testx_log.csv";fflush(stdout);}'

tail -F /var/log/messages prints the log messages as they arrive,
and will switch to the newly created log file whenever the old one
rolls over (which happens frequently when printing a line each second)

This output is piped into gawk which filters out lines that are not
our data lines (we mark these lines with the tag PAGEOUTd). It then
separates all of the values in the log with commas and prints them to
a csv file.

We also stored the value of the vmstat call throughout testing using
the following command (separated onto 3 lines):

	$ vmstat -w 1 -H | gawk '($0 !~ "procs") && ($0 !~ "flt") \
		{print strftime("%H:%M:%S") "," $4 "," $5 "," \
		$6 > "test2_vmstat.csv";fflush(stdout);}'

vmstat -w 1 -H prints the output of vmstat once every 1 second. The -H
option specifies that numbers should be raw rather than human readable
(1024 rather than 1K). This is piped into gawk which filters out the
headers and prints a timestamp followed by the avm, fre, and flt
values to a csv file.





TABLES (work in progress):

  TEST 1 (6 minute period)   GENERIC     CUSTOM
---------------------------------------------------
| average active scanned   | 113,804  |  111,357  |
| average inactive scanned | 10203    |  22978    |
| average active           | 908,516  |  903,285  | 
| average inactive         | 36,561   |  47,123   |
| average active->inactive | 1,665    |  1,403    |
| average inactive->active | 1,156    |  895      |
| average moved to cache   | 345      |  1126     |
| average flushed          | 30	      |  76       |
---------------------------------------------------





