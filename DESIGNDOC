    /****************************************************************/
   /                   #######################                      /
  /                    ## Asgn 4 Design Doc ##                     /
 /                     #######################                    /
/****************************************************************/
Team: cmhumphr, jwvance, tmakwan
Date: 3/12/16

#---------------------------------------------------------------------------#
# Intro: CryptoFS                                                           #
#---------------------------------------------------------------------------#
The goal for assignment 4 is to implement a file system in FreeBSD that will
encrypt and decrypt files upon write and read; namely: CryptoFS. Files will
be encrypted using AES (Advanced Encryption Standard) encryption on a per
file basis. CryptoFS will check the sticky bit of files (permission bit), if
the bit is set, then the file has been encrypted. If not, it exists in its
plaintext form. 

There are four major parts to this assignment: implementing a system call,
mounting nullFS and modifying it, creating a program setkey.c, and creating
a program protectfile.c.


#---------------------------------------------------------------------------#
# PART 1: Implementing a custom system call, setkey()                       #
#---------------------------------------------------------------------------#

---Steps for Implementing a System Call---
  1. Append “546  AUE_NULL  STD { int setkey(unsigned int k0, unsigned int k1);}” 
        to the syscall master library /kern/syscalls.master.
  2. cd to /sys/kern then run  $ make sysent
  3. Add the c file declaration in /sys/conf/files as "kern/sys_setkey.c  standard"
  4. Create the file sys_setkey.c in the directory /sys/kern/sys_setkey.c
  5. Declare sys_setkey in /sys/kern/capabilities.conf, label it “setkey”
  6. Build and install the customized kernel. Reboot.
  7. The system call can be called from a c program by calling it's respective 
        syscall number. For example, “syscall(546,1,1);” 

System call setkey() will take two arguments, each are 32-bit ints. These ints 
make up the least significant 64-bits of the 128-bit encryption key. The most 
significant 64-bits will be all zeros. setkey() will check the real user ID 
(r_uid) of the caller by checking the credentials of the calling thread. 

    Checking a user's ID: 
        userID = (td->td_ucred->cr_uid);
        
    The user ID and corresponding encryption key is stored in a struct:
        struct user_keys {
        	uid_t user;
        	unsigned int k0;
        	unsigned int k1;
        	int valid;
        };
        
    To support up to twenty user credentials, an array of structs is declared:
        #define KEYSTORE_LENGTH 20
        struct user_keys keylist[KEYSTORE_LENGTH];

The static array for user keys is stored in /sys/kern/sys_setkey.c. This file 
contains 


#---------------------------------------------------------------------------#
# PART 2: NullFS to CryptoFS                                                #
#---------------------------------------------------------------------------#
NullFS is a stackable file system that makes up the basis for CryptoFS. 
NullFS is a copy of the null layer, which was modified to implement the 
encryption/decryption capability. 

NullFS is already installed on FreeBSD. In order to mount it on a directory, 
the command $ mount_nullfs can be used. This command takes in two arguments: 
    1)The path to the directory to mimic 
    2) the mount point. 
    
    For example:
        $ mkdir ~/test
        $ sudo mount_nullfs /usr/bin test
        
Now /test is /usr/bin with nullfs on top of it. It works a bit like symbolic
links do.


#---------------------------------------------------------------------------#
# PART 3: The setkey.c program                                              #
#---------------------------------------------------------------------------#
The general purpose of this program is to assign a user with 




#---------------------------------------------------------------------------#
# PART 4: The protectfile.c program                                         #
#---------------------------------------------------------------------------#




