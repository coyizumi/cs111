    /****************************************************************/
   /                   #######################                      /
  /                    ## Asgn 4 Design Doc ##                     /
 /                     #######################                    /
/****************************************************************/
Team: cmhumphr, jwvance, tmakwan
Date: 3/12/16

#---------------------------------------------------------------------------#
# Intro: CryptoFS                                                           #
#---------------------------------------------------------------------------#
The goal for assignment 4 is to implement a file system in FreeBSD that will
encrypt and decrypt files upon write and read; namely: CryptoFS. Files will
be encrypted using AES (Advanced Encryption Standard) encryption on a per
file basis. CryptoFS will check the sticky bit of files (permission bit), if
the bit is set, then the file has been encrypted. If not, it exists in its
plaintext form. 

There are four major parts to this assignment: implementing a system call,
mounting nullFS and modifying it, creating a program setkey.c, and creating
a program protectfile.c.


#---------------------------------------------------------------------------#
# PART 1: Implementing a custom system call, setkey()                       #
#---------------------------------------------------------------------------#

---Steps for Implementing a System Call---
  1. Append “546  AUE_NULL  STD { int setkey(unsigned int k0, unsigned int k1);}” 
        to the syscall master library /kern/syscalls.master.
  2. cd to /sys/kern then run  $ make sysent
  3. Add the c file declaration in /sys/conf/files as "kern/sys_setkey.c  standard"
  4. Create the file sys_setkey.c in the directory /sys/kern/sys_setkey.c
  5. Declare sys_setkey in /sys/kern/capabilities.conf, label it “setkey”
  6. Build and install the customized kernel. Reboot.
  7. The system call can be called from a c program by calling it's respective 
        syscall number. For example, “syscall(546,1,1);” 

System call setkey() will take two arguments, each are 32-bit ints. These ints 
make up the least significant 64-bits of the 128-bit encryption key. The most 
significant 64-bits will be all zeros. setkey() will check the real user ID 
(r_uid) of the caller by checking the credentials of the calling thread. 

    Checking a user's ID: 
        userID = (td->td_ucred->cr_uid);
        
    The user ID and corresponding encryption key is stored in a struct:
        struct user_keys {
        	uid_t user;
        	unsigned int k0;
        	unsigned int k1;
        	int valid;
        };
        
    To support up to twenty user credentials, an array of structs is declared:
        #define KEYSTORE_LENGTH 20
        struct key_store {
          struct user_keys keylist[KEYSTORE_LENGTH];
          int len;
        };

To insert a key into the array, we loop through the list keeping track
of either the first empty slot (a slot is empty if valid is false) or
a slot that has the same uid.

In the case that the array is full, the system call returns non-zero
for failure.

To aid our cryptofs filesystem, we implement a function, get_keys_by_uid(), 
that gives the two keys associated with a given uid.

#---------------------------------------------------------------------------#
# PART 2: NullFS to CryptoFS                                                #
#---------------------------------------------------------------------------#

The cryptofs filesystem is a stackable filesystem extended from NullFS.
In addition to the standard NullFS behaviors, it encrypts writes and
decrypts reads on files with the sticky bit set.

To implement cryptofs, we first copied the NullFS code and replaced
all of the variable names with our own. We then added the crypto_read
and crypto_write functions and added them to the vnodeops struct for
cryptofs.

Initially these read and write functions simply passed their arguments
on to the bypass function, which passed them to the lower filesystem.
We then had the functions determine if the files sticky bit was set.
This was done by using the VOP_GETATTR command and using the va_mode
field of the vattr struct.

Next we began work on the encryption. For the write function, this was
easy. The data being passed to the lower layer is contained in a uio
struct. To encrypt this data, we simply looped over the uio's iovec
encrypting each byte.

The bulk of our efforts on the cryptofs filesystem consisted of figuring
out how to intercept the data from the read call. It received the same
uio struct, but the data was not entered into the struct until after
being passed to the lower filesystem. This data was being flushed on
entry though, so encrypting it afterward had no affect.

We solved this problem by replacing the buffer within the uio with
our own buffer. After returning from the lower filesystem, we encrypt
the data in this buffer and then copy it into the uio's original buffer.

To compile the new filesystem into the kernel we performed the following
steps:

  1. Created the sys/modules/cryptofs directory
  2. Copied the files from sys/modules/nullfs to this new directory
  3. Replaced all references to nullfs with cryptofs
  4. Added a cryptofs entry in sys/modules/Makefile

To mount the cryptofs filesystem, we created the program mount_cryptofs.
To do this we did the following:

  1. Copy sbin/mount_nullfs to sbin/mount_cryptofs
  2. Replace all references to nullfs with cryptofs
  3. Edit mount.c in sbin/mount to reference cryptofs

To build mount_cryptofs, simply run the makefile found in sbin/mount_cryptofs    

#---------------------------------------------------------------------------#
# PART 3: The setkey.c program                                              #
#---------------------------------------------------------------------------#
setkey.c assigns the user a unique crypto key (k0 and k1) and saves it to 
memory with their respective r_uid (real user ID). This key allows users to
encrypt and decrypt files.

setkey.c must be built using the Makefile and the command "make all". This 
will produce the setkey program. It can be run with the command:
	$ ./setkey [16 bit hex key]
setkey() parses the key into binary before storing it in the k0 and k1 fields
of the user key table. 


#---------------------------------------------------------------------------#
# PART 4: The protectfile.c program                                         #
#---------------------------------------------------------------------------#
The protectfile program is responsible for encrypting and decrypting
files. The behavior of protectfile.c varies  based on which arguments 
are passed onto the command line.

The program takes four arguments:
	1. ./protectfile
	2. -e (encrypt) or -d (decrypt)
	3. 16 bit key
	4. filename

The behavior of protectfile can be summarized:
	1. Parse the command line arguments
	2. Clear the sticky bit if it is set
	3. Generate the round key using Rijndael's algorithm
	4. Enable files by creating a file descriptor
	5. Encryption or decryption: protectfile enters a loop, reading 16 bytes from 
		the file at a time, setting the CTR value to encrypted/decrypted, then calls 
		the encryption/decryption routine to encrypt/decrypt the CTR value. Then 
		XORs the result into the file data. The result is written back to the file.
	6. Close the file. 
	7. The sticky bit is set appropriately.
