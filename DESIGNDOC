    /****************************************************************/
   /                   #######################                      /
  /                    ## Asgn 4 Design Doc ##                     /
 /                     #######################                    /
/****************************************************************/
Team: cmhumphr, jwvance, tmakwan
Date: 3/12/16

#---------------------------------------------------------------------------#
# Intro: CryptoFS                                                           #
#---------------------------------------------------------------------------#
The goal for assignment 4 is to implement a file system in FreeBSD that will
encrypt and decrypt files upon write and read; namely: CryptoFS. Files will
be encrypted using AES (Advanced Encryption Standard) encryption on a per
file basis. CryptoFS will check the sticky bit of files (permission bit), if
the bit is set, then the file has been encrypted. If not, it exists in its
plaintext form. 

There are four major parts to this assignment: implementing a system call,
mounting nullFS and modifying it, creating a program setkey.c, and creating
a program protectfile.c.


#---------------------------------------------------------------------------#
# PART 1: Implementing a custom system call, setkey()                       #
#---------------------------------------------------------------------------#

---Steps for Implementing a System Call---
  1. Append “546  AUE_NULL  STD { int setkey(unsigned int k0, unsigned int k1);}” 
        to the syscall master library /kern/syscalls.master.
  2. cd to /sys/kern then run  $ make sysent
  3. Add the c file declaration in /sys/conf/files as "kern/sys_setkey.c  standard"
  4. Create the file sys_setkey.c in the directory /sys/kern/sys_setkey.c
  5. Declare sys_setkey in /sys/kern/capabilities.conf, label it “setkey”
  6. Build and install the customized kernel. Reboot.
  7. The system call can be called from a c program by calling it's respective 
        syscall number. For example, “syscall(546,1,1);” 

System call setkey() will take two arguments, each are 32-bit ints. These ints 
make up the least significant 64-bits of the 128-bit encryption key. The most 
significant 64-bits will be all zeros. setkey() will check the real user ID 
(r_uid) of the caller by checking the credentials of the calling thread. 

    Checking a user's ID: 
        userID = (td->td_ucred->cr_uid);
        
    The user ID and corresponding encryption key is stored in a struct:
        struct user_keys {
        	uid_t user;
        	unsigned int k0;
        	unsigned int k1;
        	int valid;
        };
        
    To support up to twenty user credentials, an array of structs is declared:
        #define KEYSTORE_LENGTH 20
        struct key_store {
          struct user_keys keylist[KEYSTORE_LENGTH];
          int len;
        };

To insert a key into the array, we loop through the list keeping track
of either the first empty slot (a slot is empty if valid is false) or
a slot that has the same uid.

In the case that the array is full, the system call returns non-zero
for failure.

To aid our cryptofs filesystem, we implement a function, get_keys_by_uid(), 
that gives the two keys associated with a given uid.

#---------------------------------------------------------------------------#
# PART 2: NullFS to CryptoFS                                                #
#---------------------------------------------------------------------------#
NullFS is a stackable file system that makes up the basis for CryptoFS. 
NullFS is a copy of the null layer, which was modified to implement the 
encryption/decryption capability. 

NullFS is already installed on FreeBSD. In order to mount it on a directory, 
the command $ mount_nullfs can be used. This command takes in two arguments: 
    1)The path to the directory to mimic 
    2) the mount point. 
    
    For example:
        $ mkdir ~/test
        $ sudo mount_nullfs /usr/bin test
        
Now /test is /usr/bin with nullfs on top of it. It works a bit like symbolic
links do. To set up CryptoFS, nullFS must be copied to a new sys/modules/cryptofs 
directory. ie.:
    $ mkdir /sys/modules/cryptofs
    $ cp /sys/modules/nullfs /sys/modules/cryptofs
Once this is complete, all instances of variables referring to nullFS 
will be changed to cryptofs, this includes the Makefile. /sbin/mount_nullfs
must be modified to include "cryptofs" as a file system type. ie.:
    $ mkdir /sbin/cryptofs
    $ cp sbin/mount_nullfs sbin/mount_cryptofs
All references to "nullfs" in mount_cryptofs must be changed to "cryptofs".
    

#---------------------------------------------------------------------------#
# PART 3: The setkey.c program                                              #
#---------------------------------------------------------------------------#
setkey.c assigns the user a unique crypto key (k0 and k1) and saves it to 
memory with their respective r_uid (real user ID). This key allows users to
encrypt and decrypt files.

setkey.c must be built using the Makefile and the command "make all". This 
will produce the setkey program. It can be run with the command:
	$ ./setkey [16 bit hex key]
setkey() parses the key into binary before storing it in the k0 and k1 fields
of the user key table. 


#---------------------------------------------------------------------------#
# PART 4: The protectfile.c program                                         #
#---------------------------------------------------------------------------#
protectfile.c is the heart of the CryptoFS. It is responsible for encrypting 
and decrypting files. The behavior of protectfile.c varies  based on which 
arguments are passed onto the command line.

The program takes four arguments:
	1. ./protectfile
	2. -e (encrypt) or -d (decrypt)
	3. 16 bit key
	4. filename

The behavior of protectfile can be summarized:
	1. Parse the command line arguments
	2. Clear the sticky bit if it is set
	3. Generate the round key using Rijndael's algorithm
	4. Enable files by creating a file descriptor
	5. Encryption or decryption: protectfile enters a loop, reading 16 bytes from 
		the file at a time, setting the CTR value to encrypted/decrypted, then calls 
		the encryption/decryption routine to encrypt/decrypt the CTR value. Then 
		XORs the result into the file data. The result is written back to the file.
	6. Close the file. 
	7. The sticky bit is set appropriately.
